import Async
import Core

extension Connection {
    /// Collects all resulting rows and returs them in the future
    ///
    /// - parameter query: The query to be executed to receive results from
    /// - returns: A future containing all results
    internal func allRows(in query: Query) -> Future<[Row]> {
<<<<<<< HEAD
        let promise = Promise<[Row]>()
        
        var rows = [Row]()
        
        // Set up a parser
        let stream = RowStream(mysql41: self.mysql41)
        self.receivePackets(into: stream.inputStream)
        
        stream.onClose = {
            promise.complete(rows)
=======
        var rows = [Row]()
        
        return retain { connection, complete, fail in
            // Set up a parser
            let stream = RowStream(mysql41: connection.mysql41)
            connection.receivePackets(into: stream.inputStream)
            
            stream.onClose = {
                complete(rows)
            }
            
            stream.errorStream = { error in
                fail(error)
            }
            
            stream.drain { row in
                rows.append(row)
            }
            
            // Send the query
            do {
                try connection.write(query: query.string)
            } catch {
                fail(error)
            }
>>>>>>> 94165bfe45ef990a066b06af8dff2995ab3bf8b5
        }
        
        stream.errorStream = { error in
            promise.fail(error)
        }
        
        stream.drain { row in
            rows.append(row)
        }
        
        // Send the query
        do {
            try self.write(query: query.string)
        } catch {
            promise.fail(error)
        }
        
        return promise.future
    }
    
    /// Collects all decoded results and returs them in the future
    ///
    /// http://localhost:8000/mysql/basics/#futures
    ///
    /// - parameter query: The query to be executed to receive results from
    /// - returns: A future containing all results
    public func all<D: Decodable>(_ type: D.Type, in query: Query) -> Future<[D]> {
        var results = [D]()
        let promise = Promise<[D]>()
        
<<<<<<< HEAD
        // Set up a parser
        let resultBuilder = ModelStream<D>(mysql41: self.mysql41)
        self.receivePackets(into: resultBuilder.inputStream)
        
        resultBuilder.onClose = {
            promise.complete(results)
        }
        
        resultBuilder.errorStream = { error in
            promise.fail(error)
        }
        
        resultBuilder.drain { result in
            results.append(result)
        }
        
        // Send the query
        do {
            try self.write(query: query.string)
        } catch {
            promise.fail(error)
=======
        return retain { connection, complete, fail in
            // Set up a parser
            let resultBuilder = ModelStream<D>(mysql41: connection.mysql41)
            connection.receivePackets(into: resultBuilder.inputStream)
            
            resultBuilder.onClose = {
                complete(results)
            }
            
            resultBuilder.errorStream = { error in
                fail(error)
            }
            
            resultBuilder.drain { result in
                results.append(result)
            }
            
            // Send the query
            do {
                try connection.write(query: query.string)
            } catch {
                fail(error)
            }
>>>>>>> 94165bfe45ef990a066b06af8dff2995ab3bf8b5
        }
        
        return promise.future
    }
}
